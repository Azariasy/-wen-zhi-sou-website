# 文智搜 - 购买与激活技术实现方案 (v1.2)

**文档目的**: 本文档旨在梳理"文智搜"从用户在线购买到桌面应用激活专业版的完整技术实现方案，明确各环节的技术选型、关键逻辑、潜在难点和注意事项，作为开发和迭代的内部参考。

**核心流程**: 用户通过GitHub Pages网站下单（选择设备授权数量） -> 调用后端API创建易支付订单 -> 用户完成支付 -> 易支付回调后端API -> 后端API验证支付、生成激活码、存储订单信息（包含设备授权数量）并通过邮件发送 -> 用户在桌面应用输入激活码完成在线激活 (验证设备数量限制) -> 用户可通过桌面应用管理已激活设备。

**更新记录**:
- v1.0: 初始版本，基于单设备激活
- v1.1: 迁移至阿里云ECS，完善在线激活流程
- v1.2: 新增多设备激活支持，设备管理API及客户端实现，明确永久许可证

---

## 1. 前端实现 (GitHub Pages - `docs/purchase.html`)

**功能**: 提供产品购买入口，允许用户选择设备授权数量，收集用户信息（邮箱），调用后端API创建订单，并引导用户至支付网关。

**技术栈**: HTML, CSS, JavaScript

**关键逻辑与实现点**:

1.  **用户界面 (UI)**:
    *   清晰展示产品信息、不同设备授权数量对应的价格（例如：单设备¥X, 三设备¥Y, 六设备¥Z）。
    *   **新增**: 提供设备数量选择控件 (例如，下拉菜单或单选按钮)。
    *   提供邮箱输入框 (`<input type="email" id="user-email">`)。
    *   设置"立即购买"按钮 (`<button id="buy-now-button">`)。
    *   反馈区域，用于显示加载状态或错误信息。

2.  **用户交互与数据验证 (JavaScript)**:
    *   **事件监听**: 给"立即购买"按钮添加 `click` 事件监听器。
    *   **数据获取与校验**:
        *   获取用户输入的邮箱地址并进行客户端格式校验。
        *   **新增**: 获取用户选择的设备授权数量 (`deviceLimit`)。
        *   获取对应的产品ID (`productId`) 和价格 (`amount`)。
        *   若校验失败，向用户显示错误提示。
    *   **按钮状态管理**: 点击购买后禁用按钮，显示加载提示。

3.  **API 调用 (`fetch` API)**:
    *   **目标API**: `https://<您的后端服务域名>/api/create-order` (已从Vercel迁移)
    *   **方法**: `POST`
    *   **请求头**: `Content-Type: application/json`
    *   **请求体 (Body)**: JSON字符串，包含：
        *   `email`: 用户输入的邮箱。
        *   `productId`: 产品标识符 (可能需要根据设备数量调整，或传递设备数量作为单独参数)。
        *   `amount`: 对应设备数量的价格。
        *   `description`: 产品描述 (例如, "文智搜专业版 - 3设备授权")。
        *   **新增**: `deviceLimit`: 用户选择的设备数量 (e.g., 1, 3, 6)。
    *   **示例代码 (更新后)**:
        ```javascript
        // ... (获取email, productId, amount, description, deviceLimit)
        try {
            const response = await fetch('https://<您的后端服务域名>/api/create-order', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ email, productId, amount, description, deviceLimit })
            });
            const data = await response.json();
            if (response.ok && data.code === 0 && data.payUrl) {
                window.location.href = data.payUrl; // 跳转到支付页面
            } else {
                // 显示错误信息 data.msg
            }
        } catch (error) {
            // 显示网络或请求错误信息
        } finally {
            // 恢复按钮状态
        }
        ```

4.  **响应处理**: 同v1.1，成功则跳转支付，失败则显示错误。

**关键点与注意事项**: 
*   **CORS**: 后端API需配置正确的CORS策略。
*   **价格与设备数量联动**: 确保前端正确根据用户选择的设备数量传递对应的 `productId`, `amount`, `description`, 和 `deviceLimit`。
*   **后端域名**: 注意API端点已指向新的后端服务域名。

---

## 2. 后端API (后端服务 - Node.js)

**技术栈**: Node.js, MongoDB Driver (`mongodb`), `axios`, `nodemailer`, `cors`

**环境变量 (更新后)**:
*   `MONGODB_URI`: MongoDB连接字符串。
*   `DB_NAME`: MongoDB数据库名称。
*   `YIPAY_PID`, `YIPAY_KEY`, `YIPAY_API_URL`: 易支付配置。
*   `SMTP_HOST`, `SMTP_PORT`, `SMTP_SECURE`, `SMTP_USER`, `SMTP_PASS`, `EMAIL_FROM_ADDRESS`: SMTP邮件配置。
*   `NOTIFY_URL_BASE`: 回调 URL 基础 (例如 `https://<您的后端服务域名>`)。
*   `FRONTEND_SUCCESS_URL`: 前端支付成功跳转页。
*   `LICENSE_SECRET`: (可选) 用于生成激活码的密钥。
*   `NODE_ENV`: 运行环境。
*   **移除**: `YIPAY_CALLBACK_VALIDATION_KEY` (如果未使用)。

### 2.1 创建订单 API (`api/create-order.js`)

**路径**: `/api/create-order`
**方法**: `POST`

**功能**: 接收前端下单请求（包含设备数量），与易支付交互创建订单，将订单信息（包含设备限制）存入MongoDB，返回支付URL。

**关键逻辑与实现点 (更新后)**:

1.  **CORS 处理**: 使用 `cors` 中间件或手动设置响应头。
2.  **请求数据解析与校验**: 
    *   从 `req.body` 获取 `email`, `productId`, `amount`, `description`, **`deviceLimit`**。
    *   进行校验，特别是 `deviceLimit` 应为有效数字 (e.g., 1, 3, 6)。
3.  **生成订单号**: 同v1.1。
4.  **与易支付API交互**: 同v1.1，使用获取到的 `amount` 等信息。
5.  **存储订单到MongoDB (更新后)**:
    *   **数据模型 (`orders` 集合) (更新后)**:
        *   `orderNo`: String (唯一索引)
        *   `userEmail`: String
        *   `productId`: String
        *   `amount`: Number
        *   `description`: String
        *   **`maxDevices`**: Number (存储购买的设备授权数量, e.g., 1, 3, 6) - **代替或补充原 `deviceLimit` 概念**
        *   `status`: String (e.g., "pending", "paid", "failed")
        *   `paymentGateway`: String (e.g., "yipay")
        *   `gatewayTradeNo`: String
        *   `createdAt`: Date
        *   `updatedAt`: Date
        *   `paidAt`: Date
        *   `licenseKey`: String (支付成功后生成)
        *   `licenseGeneratedAt`: Date
        *   `licenseSentAt`: Date
        *   **`activatedDevices`**: Array of Objects (存储已激活设备信息) - **代替原 `licenseDeviceId` 和 `licenseActivatedAt`**
            *   `deviceId`: String
            *   `deviceName`: String (可选, 用户可自定义)
            *   `activatedAt`: Date
            *   `lastCheckinAt`: Date (可选, 记录设备最后活跃时间)
        *   `licenseStatus`: String (e.g., "active", "inactive", "revoked") - **修改：所有许可证永久有效，不再需要过期状态**
        *   `paymentCallbackData`: Object
    *   将包含 `orderNo`, `userEmail`, `productId`, `amount`, **`maxDevices`** (从 `req.body.deviceLimit` 获取), `status: "pending"`, `createdAt` 等信息的订单文档插入 `orders` 集合。
6.  **返回响应给前端**: 同v1.1。

**难点与注意事项**: 
*   确保 `maxDevices` 正确存储。

### 2.2 支付回调 API (`api/payment-callback.js`)

**路径**: `/api/payment-callback`
**方法**: 由易支付决定 (GET/POST)

**功能**: 接收易支付通知，验证，更新订单状态，生成激活码，发送邮件。

**关键逻辑与实现点 (与v1.1基本一致，核心在于更新订单)**:

1.  接收与解析通知。
2.  签名验证。
3.  处理业务逻辑 (检查 `trade_status`, 检查订单状态防重复)。
4.  **更新订单状态**: 若成功且 pending:
    *   `status` -> "paid"
    *   记录 `gatewayTradeNo`
    *   记录 `paidAt`
    *   更新 `updatedAt`
5.  **生成激活码**: 同v1.1，生成唯一 `licenseKey` 并更新到订单记录。
6.  **发送激活码邮件**: 同v1.1，使用 `nodemailer` 发送包含 `licenseKey` 的邮件。
7.  响应易支付 (`success`)。

**难点与注意事项**: 
*   签名验证、幂等性处理仍是关键。

### 2.3 激活许可证 API (`api/activate-license.js`)

**路径**: `/api/activate-license`
**方法**: `POST`

**功能**: 接收桌面应用的激活请求（含激活码和设备ID），验证激活码，检查设备数量限制，记录激活设备信息。

**关键逻辑与实现点 (重大更新)**:

1.  **请求体 (JSON)**: `{ "licenseKey": "...", "deviceId": "...", "deviceName": "..." (可选) }`
2.  **数据库连接**: 连接 MongoDB。
3.  **验证逻辑**: 
    *   **激活码有效性**: 在 `orders` 集合中根据 `licenseKey` 查询订单。若不存在或 `status` 不是 `paid`，返回失败。
    *   **设备激活状态检查**: 
        *   获取订单记录中的 `maxDevices` 和 `activatedDevices` 数组。
        *   **检查设备是否已激活**: 遍历 `activatedDevices`，查找是否存在具有相同 `deviceId` 的记录。
            *   **如果找到**: 设备已激活。返回成功，消息为 "设备已激活"，并包含 `alreadyActivated: true` 和设备信息 (如原激活时间)。
            *   **如果未找到**: 继续检查设备数量限制。
        *   **检查设备数量限制**: 比较 `activatedDevices.length` 和 `maxDevices`。
            *   **如果 `activatedDevices.length >= maxDevices`**: 已达到设备数量上限。返回失败，消息为 "激活失败：已达到最大设备数量限制。"。
            *   **如果 `activatedDevices.length < maxDevices`**: 允许激活新设备。
                *   创建新的设备对象: `{ deviceId, deviceName (如果提供), activatedAt: new Date() }`。
                *   使用 MongoDB 的 `$addToSet` 或 `$push` 操作将新设备对象添加到 `activatedDevices` 数组中。
                *   更新订单的 `updatedAt` 字段。
                *   返回激活成功，消息为 "激活成功！"，并包含 `alreadyActivated: false` 和许可证详情（包括 `maxDevices` 和当前的 `activatedDevices` 列表）。
4.  **返回响应给桌面应用 (JSON) (更新后)**:
    *   **成功 (新设备)**: `{ "success": true, "message": "激活成功！", "userEmail": "...", "productId": "...", "maxDevices": 3, "activatedDevices": [...], "alreadyActivated": false }`
    *   **成功 (设备已激活)**: `{ "success": true, "message": "设备已激活。", "userEmail": "...", "productId": "...", "maxDevices": 3, "activatedDevices": [...], "alreadyActivated": true }`
    *   **失败 (超限)**: `{ "success": false, "message": "激活失败：已达到最大设备数量限制。" }`
    *   **失败 (无效码等)**: `{ "success": false, "message": "激活失败：无效的激活码或订单未支付。" }`
5.  **日志记录**: 记录详细日志。

**难点与注意事项**: 
*   MongoDB 更新操作的原子性（`$addToSet` 或 `$push` 结合条件查询通常是原子的）。
*   并发处理：如果同一激活码被极快地在多台新设备上同时尝试激活，需要数据库层面的机制或应用层锁来确保不超过 `maxDevices` 限制 (虽然概率低)。

### 2.4 设备管理 API (`api/device-management.js`) [新增]

**功能**: 提供列出已激活设备和注销（停用）特定设备的功能。

**子路径与方法**: 
*   **列出设备**: `GET /api/devices?licenseKey=...`
*   **注销设备**: `POST /api/devices/deactivate` (请求体: `{ "licenseKey": "...", "deviceId": "..." }`)

**关键逻辑与实现点**: 

1.  **身份验证/授权**: **极其重要**。如何确保只有许可证的合法持有者能管理设备？
    *   **方案一 (简单)**: 仅依赖 `licenseKey`。知道激活码就能管理。安全性较低。
    *   **方案二 (推荐)**: 需要额外的验证，例如发送验证链接到用户邮箱，或要求用户登录（如果实现用户账户系统）。 **初期可先实现基于 licenseKey 的管理，但需明确其安全风险。**
2.  **列出设备 (GET /api/devices)**:
    *   获取 `licenseKey`。
    *   (执行身份验证)
    *   查询 `orders` 集合，找到对应 `licenseKey` 的订单。
    *   如果找到，返回 `activatedDevices` 数组。
    *   如果未找到或验证失败，返回错误。
3.  **注销设备 (POST /api/devices/deactivate)**:
    *   获取 `licenseKey` 和 `deviceId`。
    *   (执行身份验证)
    *   查询 `orders` 集合。
    *   使用 MongoDB 的 `$pull` 操作从 `activatedDevices` 数组中移除具有指定 `deviceId` 的设备对象。
    *   更新 `updatedAt`。
    *   返回成功或失败信息。
4.  **CORS 配置**: 需要为这些新端点配置CORS。
5.  **日志记录**: 记录设备管理操作。

**难点与注意事项**: 
*   **安全性**: 未经授权的设备管理是重大风险。
*   **客户端同步**: 客户端需要在设备被远程注销后能感知到变化（例如，下次启动时在线检查许可证状态，或定期检查）。

--- 

## 3. 数据库 (MongoDB)

**数据模型 (`orders` 集合) (更新后)**:

*   `_id`: ObjectId
*   `orderNo`: String, unique: true, index: true
*   `userEmail`: String, index: true
*   `productId`: String
*   `amount`: Number
*   `description`: String
*   **`maxDevices`**: Number, index: true (购买的设备授权数量)
*   `status`: String, index: true (e.g., "pending", "paid")
*   `paymentGateway`: String
*   `gatewayTradeNo`: String
*   `createdAt`: ISODate
*   `paidAt`: ISODate
*   `licenseKey`: String, unique: true, sparse: true, index: true
*   `licenseGeneratedAt`: ISODate
*   `licenseSentAt`: ISODate
*   **`activatedDevices`**: Array of Objects, index: true (on `deviceId` within the array if needed)
    *   `deviceId`: String
    *   `deviceName`: String (可选)
    *   `activatedAt`: ISODate
    *   `lastCheckinAt`: ISODate (可选)
*   `licenseStatus`: String (固定为 "active" 或移除，因为永久有效)
*   `paymentCallbackData`: Object

**关键点**: 
*   为 `maxDevices`, `licenseKey`, `activatedDevices.deviceId` (如果需要频繁按设备ID查询) 创建索引。
*   数据模型变化需要确保所有API正确读写。

--- 

## 4. 桌面应用程序 (文智搜)

**技术栈**: Python, PyQt/PySide

**功能**: 提供激活界面，验证激活码（在线），存储激活状态和设备信息，根据状态解锁功能，**新增设备管理界面**。

**关键逻辑与实现点 (更新后)**:

1.  **激活界面 (`LicenseDialog`)**: 
    *   输入激活码。
    *   显示当前许可证状态（免费/专业版，邮箱，**最大设备数，当前激活设备数**）。
    *   "激活"按钮。
    *   **新增**: "管理设备"按钮，用于打开设备管理对话框。
    *   反馈信息（激活中、成功、失败原因）。

2.  **激活码验证逻辑 (`license_activation.py`) (更新后)**:
    *   **必须在线验证**: 调用后端 `api/activate-license`。
    *   发送 `licenseKey`, `deviceId` (客户端生成), `deviceName` (可选, 可让用户输入)。
    *   处理后端返回的 JSON 响应：
        *   成功: 更新本地存储的许可证信息 (包括 `maxDevices`, `activatedDevices` 列表)。
        *   失败: 显示明确的错误信息给用户。

3.  **许可证状态存储 (本地) (`license_manager.py`) (更新后)**:
    *   验证成功后，安全存储：
        *   `licenseKey`: String
        *   `deviceId`: String (当前设备的ID)
        *   `isPro`: Boolean (True)
        *   `userEmail`: String
        *   `productId`: String
        *   **`maxDevices`**: Int
        *   **`activatedDevices`**: List[Dict] (存储从服务器获取的完整列表)
        *   `activationDate`: String (可以记录首次激活时间，或当前设备的激活时间)
    *   存储位置和安全性要求同v1.1。

4.  **专业功能解锁**: 同v1.1，检查 `LicenseManager.is_pro()`。

5.  **设备管理功能 [新增]**: 
    *   **设备管理对话框 (`DeviceManagerDialog`)**: 
        *   UI: 使用 `QTableWidget` 或 `QListView` 显示 `activatedDevices` 列表 (设备ID, 设备名, 激活日期)。
        *   高亮显示当前设备。
        *   提供"注销"按钮 (对非当前设备)。
    *   **数据加载与刷新 (`license_activation.py`)**: 
        *   添加函数调用后端 `GET /api/devices` 获取最新的设备列表。
        *   在打开设备管理对话框时调用。
    *   **设备注销 (`license_activation.py`)**: 
        *   添加函数调用后端 `POST /api/devices/deactivate` 发送 `licenseKey` 和要注销的 `deviceId`。
        *   处理响应，成功后刷新设备列表。
        *   **本地状态更新 (`license_manager.py`)**: 
            *   从服务器获取或注销成功后，更新本地存储的 `activatedDevices` 列表。

**难点与注意事项**: 
*   **设备ID生成**: 仍然需要稳定唯一的 `deviceId`。
*   **本地存储安全**: 加密是必须的。
*   **API调用**: 正确处理网络请求和错误。
*   **UI/UX**: 设备管理界面要清晰易用。
*   **状态同步**: 本地存储的设备列表可能与服务器不完全同步（例如，在离线时另一台设备被注销）。应用启动时或定期在线检查可以缓解这个问题。

--- 

## 5. 第三方服务集成 (与v1.1一致)

*   易支付配置与API对接。
*   邮件服务 (SMTP) 配置与使用。

--- 

## 6. 整体流程中的关键点与挑战 (更新后)

1.  **安全性**: 
    *   **设备管理API的授权** 是新增的关键挑战。
    *   本地存储加密、API安全、凭证管理依然重要。
2.  **数据一致性**: 确保客户端和服务器端的设备列表状态尽可能一致。
3.  **错误处理与日志**: 覆盖新增API和客户端逻辑。
4.  **用户体验**: 多设备激活和管理流程需要清晰引导。

---

本文档为v1.2版本，主要更新了多设备支持和设备管理功能。 