# 文智搜 - 购买与激活技术实现方案 (v1.1)

**文档目的**: 本文档旨在梳理"文智搜"从用户在线购买到桌面应用激活专业版的完整技术实现方案，明确各环节的技术选型、关键逻辑、潜在难点和注意事项，作为开发和迭代的内部参考。

**核心流程**: 用户通过GitHub Pages网站下单 -> 调用阿里云ECS后端API创建易支付订单 -> 用户完成支付 -> 易支付回调阿里云ECS API -> 后端API验证支付、生成激活码、存库并通过邮件发送 -> 用户在桌面应用输入激活码完成在线激活。

---

## 1. 前端实现 (GitHub Pages - `docs/purchase.html`)

**功能**: 提供产品购买入口，收集用户信息（邮箱），调用后端API创建订单，并引导用户至支付网关。

**技术栈**: HTML, CSS, JavaScript

**关键逻辑与实现点**:

1.  **用户界面 (UI)**:
    *   清晰展示产品信息、价格（例如：¥99 终身版）。
    *   提供邮箱输入框 (`<input type="email" id="user-email">`)。
    *   设置"立即购买"按钮 (`<button id="buy-now-button">`)。
    *   反馈区域，用于显示加载状态或错误信息。

2.  **用户交互与数据验证 (JavaScript)**:
    *   **事件监听**: 给"立即购买"按钮添加 `click` 事件监听器。
    *   **邮箱获取与校验**:
        *   获取用户输入的邮箱地址。
        *   进行客户端邮箱格式校验 (使用正则表达式 ` /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/`)。
        *   若校验失败，向用户显示错误提示。
    *   **按钮状态管理**:
        *   点击购买后，禁用按钮，显示"处理中..."或类似加载提示，防止重复提交。
        *   API调用成功或失败后，恢复按钮状态。

3.  **API 调用 (`fetch` API)**:
    *   **目标API**: `https://<您的阿里云ECS域名>/api/create-order`
    *   **方法**: `POST`
    *   **请求头**:
        *   `Content-Type: application/json`
    *   **请求体 (Body)**: JSON字符串，包含：
        *   `email`: 用户输入的邮箱。
        *   `productId`: 产品标识符 (例如, `"wenzhisou-pro-lifetime"`)。
        *   `amount`: 产品价格 (例如, `99.00`)。
        *   `description`: 产品描述 (例如, `"文智搜专业版 - 终身授权"`)。
    *   **示例代码**:
        ```javascript
        // ... (获取email, productId, amount, description)
        try {
            const response = await fetch('https://<您的阿里云ECS域名>/api/create-order', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ email, productId, amount, description })
            });
            const data = await response.json();
            if (response.ok && data.code === 0 && data.payUrl) {
                window.location.href = data.payUrl; // 跳转到支付页面
            } else {
                // 显示错误信息 data.msg
            }
        } catch (error) {
            // 显示网络或请求错误信息
        } finally {
            // 恢复按钮状态
        }
        ```

4.  **响应处理**:
    *   **成功**:
        *   API返回 `code: 0` 和 `payUrl`。
        *   使用 `window.location.href = data.payUrl;` 将用户重定向到易支付提供的支付链接。
    *   **失败**:
        *   API返回非0的 `code` 和错误信息 `msg`。
        *   在前端页面上向用户显示错误信息。

**关键点与注意事项**:
*   **CORS**: 前端域名 (e.g., `azariasy.github.io`) 与后端API域名 (e.g., `<您的阿里云ECS域名>`) 不同，后端API必须正确配置CORS。
*   **用户反馈**: 提供清晰的加载指示和错误提示。
*   **安全性**: 客户端验证仅为初步，核心验证需在后端进行。
*   **配置**: 产品ID、价格、API端点等应易于配置（例如，在JS文件顶部定义为常量）。

---

## 2. 后端API (阿里云 ECS - Node.js 服务)

**技术栈**: Node.js, MongoDB Driver (`mongodb`), `axios` (或 `node-fetch`), `nodemailer`

**环境变量 (阿里云 ECS 服务器配置)**:
*   `MONGODB_URI`: MongoDB连接字符串。
*   `DB_NAME`: MongoDB数据库名称 (例如 `wenzisou`)。
*   `YIPAY_PID`: 易支付商户PID。
*   `YIPAY_KEY`: 易支付商户密钥。
*   `YIPAY_API_URL`: 易支付API提交网关URL (例如 `https://your-yipay-api.com/submit.php`)。
*   `YIPAY_CALLBACK_VALIDATION_KEY`: (可选) 用于增强回调验证的自定义密钥。
*   `SMTP_HOST`: 邮件服务器主机 (例如 `smtp.qq.com`)。
*   `SMTP_PORT`: 邮件服务器端口 (例如 `465` 或 `587`)。
*   `SMTP_SECURE`: 是否使用SSL/TLS (例如 `true` for 465, `false` for 587)。
*   `SMTP_USER`: 发件邮箱账号 (例如您的QQ邮箱 `example@qq.com`)。
*   `SMTP_PASS`: 发件邮箱的**授权码** (非登录密码)。
*   `EMAIL_FROM_ADDRESS`: 发件人邮箱地址 (通常与 `SMTP_USER` 一致)。
*   `NOTIFY_URL_BASE`: 回调 URL 的基础部分，例如 `https://<您的阿里云ECS域名>`。
*   `FRONTEND_SUCCESS_URL`: 前端支付成功跳转页 (例如 `https://azariasy.github.io/-wen-zhi-sou-website/purchase-success.html`)。
*   `LICENSE_SECRET`: (可选) 用于生成激活码的强随机密钥。
*   `NODE_ENV`: 运行环境 (例如 `production` 或 `development`)。

### 2.1 创建订单 API (`api/create-order.js`)

**路径**: `/api/create-order`
**方法**: `POST`

**功能**: 接收前端下单请求，与易支付API交互创建订单，将订单信息存入MongoDB，并返回支付URL。

**关键逻辑与实现点**:

1.  **CORS 处理**:
    *   在Node.js应用中使用 `cors` 中间件或手动设置响应头，允许来自GitHub Pages域名的跨域请求。
    *   正确响应 `OPTIONS` 预检请求。
    *   设置 `Access-Control-Allow-Origin`, `Access-Control-Allow-Methods`, `Access-Control-Allow-Headers` 响应头。
    ```javascript
    // 示例 CORS 头部设置
    res.setHeader('Access-Control-Allow-Origin', 'https://azariasy.github.io'); // 或更灵活的 origin 检查
    res.setHeader('Access-Control-Allow-Methods', 'POST, OPTIONS');
    res.setHeader('Access-Control-Allow-Headers', 'Content-Type');
    if (req.method === 'OPTIONS') {
      return res.status(204).end();
    }
    ```

2.  **请求数据解析与校验**:
    *   从 `req.body` 获取 `email`, `productId`, `amount`, `description`。
    *   进行必要性校验和格式校验（特别是 `email`）。
    *   若校验失败，返回 `400 Bad Request` 及错误信息。

3.  **生成订单号**:
    *   创建全局唯一的订单号 (例如 `WZS_` + 时间戳 + 随机数)。
    *   `const orderNo = \`WZS\${Date.now()}\${Math.floor(Math.random() * 10000)};\`

4.  **与易支付API交互**:
    *   **参数准备**:
        *   `pid`: 易支付商户ID (从环境变量读取)。
        *   `type`: 支付方式 (例如, `alipay`, `wxpay`, `qqpay` - 可由前端传递或后端配置)。
        *   `out_trade_no`: 商户订单号 (使用上面生成的 `orderNo`)。
        *   `notify_url`: 异步回调通知URL (例如, `https://${process.env.NOTIFY_URL_BASE}/api/payment-callback`)。
        *   `return_url`: 同步跳转URL (例如, `${process.env.FRONTEND_SUCCESS_URL}`)。
        *   `name`: 商品名称 (例如, `req.body.description`)。
        *   `money`: 金额 (例如, `req.body.amount`)。
        *   `sign_type`: `MD5`。
        *   `sign`: 根据易支付规则生成的签名。
            *   签名逻辑：将除 `sign` 外的参数按key字典序排序，拼接成 `key1=value1&key2=value2...` 形式，末尾加上商户密钥 `&key=YIPAY_KEY`，然后计算MD5值。
    *   **发送请求**: 使用 `axios` 或 `node-fetch` 向易支付API网关发送 `POST` 或 `GET` 请求 (根据易支付文档)。
    *   **处理响应**:
        *   易支付通常会返回一个包含支付链接的HTML页面、JSON数据或直接重定向。
        *   解析响应，提取支付URL (`payUrl`)。
        *   若易支付返回错误，记录日志并返回错误给前端。

5.  **存储订单到MongoDB**:
    *   **数据模型 (`orders` 集合)**:
        *   `orderNo`: String (唯一索引)
        *   `userEmail`: String
        *   `productId`: String
        *   `amount`: Number
        *   `description`: String
        *   `status`: String (e.g., "pending", "paid", "failed", "expired", "activated") - 初始为 "pending"
        *   `paymentGateway`: String (e.g., "yipay")
        *   `gatewayTradeNo`: String (易支付的交易号，支付成功后更新)
        *   `createdAt`: Date
        *   `updatedAt`: Date
        *   `paidAt`: Date (支付成功时间)
        *   `licenseKey`: String (支付成功后生成并更新)
        *   `licenseGeneratedAt`: Date (激活码生成时间)
        *   `licenseSentAt`: Date (邮件发送时间)
        *   `licenseActivatedAt`: Date (激活时间，通过`api/activate-license.js`更新)
        *   `licenseDeviceId`: String (绑定的设备ID，通过`api/activate-license.js`更新)
        *   `licenseStatus`: String (e.g., "pending", "active", "revoked")
        *   `paymentCallbackData`: Object (存储易支付回调的原始数据，供审计)
    *   连接MongoDB，将包含 `orderNo`, `userEmail`, `productId`, `amount`, `status: "pending"`, `createdAt` 等信息的订单文档插入 `orders` 集合。
    *   若数据库操作失败，记录日志并返回错误给前端。

6.  **返回响应给前端**:
    *   **成功**: `res.status(200).json({ code: 0, msg: '订单创建成功', payUrl: '易支付返回的支付链接' });`
    *   **失败**: `res.status(500).json({ code: 1, msg: '错误信息' });`

**难点与注意事项**:
*   **签名生成**: 易支付的签名算法务必正确实现。
*   **错误处理**: 仔细处理易支付API调用失败、数据库操作失败等情况。
*   **安全性**: 保护易支付密钥。
*   **幂等性**: 考虑如何处理前端重复提交创建订单的请求（虽然前端有按钮禁用，但不能完全依赖）。可在数据库层面通过 `orderNo` (如果 `orderNo` 在调用易支付前已生成并尝试存库) 或其他唯一请求ID进行控制。

### 2.2 支付回调 API (`api/payment-callback.js`)

**路径**: `/api/payment-callback`
**方法**: 通常为 `GET` 或 `POST` (由易支付平台决定并配置)

**功能**: 接收易支付平台的异步支付结果通知，验证通知，更新订单状态，生成并发送激活码。

**关键逻辑与实现点**:

1.  **接收与解析通知**:
    *   从 `req.query` (GET) 或 `req.body` (POST) 获取易支付发送的参数，例如：
        *   `pid`, `trade_no` (易支付交易号), `out_trade_no` (商户订单号), `type`, `name`, `money`, `trade_status` (e.g., `TRADE_SUCCESS`), `sign`, `sign_type`。

2.  **签名验证**:
    *   **极其重要**: 验证接收到的通知的 `sign` 是否有效，以确认通知来自易支付且未被篡改。
    *   签名验证逻辑与创建订单时类似：将接收到的除 `sign` 外的参数按key字典序排序，拼接成 `key1=value1&key2=value2...` 形式，末尾加上商户密钥 `&key=YIPAY_KEY`，计算MD5值，与接收到的 `sign` 对比。
    *   若签名验证失败，返回错误响应给易支付 (通常是特定字符串如 `fail`)，并不再处理。

3.  **处理业务逻辑**:
    *   **检查 `trade_status`**: 确认支付是否成功 (例如, `trade_status === 'TRADE_SUCCESS'`)。
    *   **检查订单状态 (防重复处理)**:
        *   使用 `out_trade_no` (即 `orderNo`) 从MongoDB中查询订单。
        *   如果订单不存在或订单状态已经是 "paid"，则可能为重复通知，直接返回成功响应给易支付，避免重复处理。
    *   **更新订单状态**:
        *   若支付成功且订单状态为 "pending"：
            *   将订单 `status` 更新为 "paid"。
            *   记录 `gatewayTradeNo` (易支付的 `trade_no`)。
            *   更新 `updatedAt`。

4.  **生成激活码 (License Key)**:
    *   如果支付成功：
        *   生成一个唯一的、具有一定复杂度的激活码。格式例如 `XXXX-XXXX-XXXX-XXXX`。
        *   生成方法：可以使用UUID库，或组合时间戳、随机字符串等，并进行格式化。
        *   确保激活码在系统中是唯一的 (可在数据库中检查)。
        *   将生成的 `licenseKey` 更新到MongoDB的对应订单记录中。

5.  **发送激活码邮件**:
    *   如果支付成功且激活码已生成并存库：
    *   使用 `nodemailer` 和配置好的SMTP服务器 (例如QQ邮箱) 发送邮件给用户的 `userEmail` (从订单记录中获取)。
    *   **邮件内容**:
        *   感谢语。
        *   订单信息 (订单号)。
        *   **激活码**。
        *   简单的激活步骤指引。
        *   技术支持联系方式。
    *   **邮件模板**: 建议使用HTML模板以获得更好的邮件外观。
    *   **错误处理**: 邮件发送失败需要记录日志，并考虑后续补发机制（例如，手动补发或用户通过支持渠道索取）。

6.  **响应易支付**:
    *   根据易支付的要求，处理成功后返回特定字符串 (例如, `success` 或 `OK`)。
    *   如果处理过程中发生内部错误，也应尽量返回 `success`，避免易支付不断重试通知，但要记录详细错误日志供排查。

**难点与注意事项**:
*   **安全性**: 签名验证是核心安全措施。
*   **幂等性**: 必须能正确处理易支付的重复回调通知。
*   **事务性/数据一致性**: 更新订单状态、生成激活码、发送邮件等操作，如果其中一步失败，如何保证数据一致性或进行补偿？（例如，记录失败状态，后续人工处理或定时任务重试）。对于小型系统，确保关键步骤记录日志，优先保证更新数据库状态，邮件发送失败可后续处理。
*   **激活码唯一性**: 生成激活码时要确保其唯一。
*   **邮件发送可靠性**: SMTP服务可能会有发送限制或被标记为垃圾邮件。

### 2.3 检查支付状态 API (`api/check-payment-status.js`) - (可选/辅助)

**路径**: `/api/check-payment-status`
**方法**: `GET`

**功能**: (主要用于调试或特定场景) 允许查询特定订单的支付状态。

**关键逻辑**:
1.  接收 `orderNo` 作为查询参数 (`req.query.orderNo`)。
2.  从MongoDB中查询该 `orderNo` 的订单。
3.  返回订单的 `status` 和其他相关信息。
4.  需要考虑权限控制，不能随意查询。

---

## 3. 数据库 (MongoDB)

**选型**: MongoDB Atlas (云服务) 或自托管。

**数据模型**:

*   **`orders` 集合**: (已在 `create-order.js` 部分详述)
    *   `_id`: ObjectId (MongoDB自动生成)
    *   `orderNo`: String, unique: true, index: true
    *   `userEmail`: String, index: true
    *   `productId`: String
    *   `amount`: Number
    *   `description`: String
    *   `status`: String, index: true (e.g., "pending", "paid", "failed", "cancelled", "refunded")
    *   `paymentGateway`: String (e.g., "yipay")
    *   `gatewayTradeNo`: String (易支付交易号)
    *   `createdAt`: ISODate
    *   `paidAt`: ISODate (支付成功时间)
    *   `licenseKey`: String, unique: true, sparse: true (仅在支付成功后存在)
    *   `licenseGeneratedAt`: ISODate
    *   `licenseSentAt`: ISODate (邮件发送时间)
    *   `licenseActivatedAt`: Date (激活时间，通过`api/activate-license.js`更新)
    *   `licenseDeviceId`: String (绑定的设备ID，通过`api/activate-license.js`更新)
    *   `licenseStatus`: String (e.g., "pending", "active", "revoked")
    *   `paymentCallbackData`: Object (存储易支付回调的原始数据，供审计)

*   **(可选) `licenses` 集合**: 如果激活码管理逻辑复杂，可以单独建表。但目前方案倾向于将激活相关信息存储在 `orders` 集合中。
    *   `_id`: ObjectId
    *   `licenseKey`: String, unique: true, index: true
    *   `orderNo`: String, index: true (关联到 `orders` 表的 `orderNo`)
    *   `userEmail`: String
    *   `productId`: String
    *   `generatedAt`: ISODate
    *   `status`: String (e.g., "active", "inactive", "revoked", "expired") - 例如 "active"
    *   `activatedAt`: ISODate
    *   `deviceId`: String (用于单设备激活限制)
    *   `activationHistory`: Array of Objects (记录激活/停用历史)

**关键点**:
*   **索引**: 为经常查询的字段 (如 `orderNo`, `userEmail`, `licenseKey`, `status`, `licenseDeviceId`) 创建索引以提高查询性能。
*   **安全性**: 使用强密码，限制网络访问，定期备份。
*   **连接管理**: 在Node.js应用中正确管理数据库连接池。

---

## 4. 桌面应用程序 (文智搜)

**技术栈**: Python, PyQt/PySide

**功能**: 提供激活界面，验证用户输入的激活码，存储激活状态，并根据激活状态解锁专业版功能。

**关键逻辑与实现点**:

1.  **激活界面 (UI)**:
    *   提供一个输入框供用户输入激活码。
    *   显示当前许可证状态（免费版/专业版，激活日期等）。
    *   "激活"按钮。
    *   激活过程中的用户反馈得到改善，例如通过更明确的"请稍候"提示及其正确的关闭（通过 `progress_msg.done(0)` 和 `QApplication.processEvents()`），保证了对话框在激活尝试后的响应性和交互性。

2.  **激活码验证逻辑**:
    *   **方式一: 离线格式校验 (初期简单实现)**:
        *   用户输入激活码后，客户端仅检查其格式是否符合预设规则 (例如, `XXXX-XXXX-XXXX-XXXX`)。
        *   **安全性极低，易被破解，不推荐作为最终方案，仅用于快速原型验证。**
    *   **方式二: 在线验证 (推荐的长期方案)**:
        *   **新建后端API**: `api/activate-license.js` (部署在阿里云 ECS)。
        *   用户在桌面应用输入激活码后，应用向此API发送请求，包含 `licenseKey` 和一个唯一的设备标识符 (`deviceId`).
        *   **`api/activate-license.js` 后端逻辑 (Node.js) (更新后)**:
            *   **路径**: `/api/activate-license`
            *   **方法**: `POST`
            *   **请求体 (JSON)**: `{ "licenseKey": "USER_INPUT_KEY", "deviceId": "UNIQUE_DEVICE_ID" }`
            *   **处理流程**: 
                1.  接收 `licenseKey` 和 `deviceId`。
                2.  **数据库连接**: 连接到 MongoDB Atlas，使用环境变量 `MONGODB_URI` (包含数据库名) 或 `MONGODB_URI` 和 `DB_NAME` (如果分开配置)。在连接前检查 `MONGODB_URI` 是否已配置，如未配置则记录错误并返回服务器错误。
                3.  **验证逻辑 (核心更新)**:
                    *   **激活码存在性**: 在 `orders` 集合中根据 `licenseKey` 查询订单。若激活码不存在，返回激活失败。
                    *   **订单状态**: 检查对应订单的 `status` 是否为 `paid`。若未支付，返回激活失败。
                    *   **设备绑定与激活状态判断**:
                        *   查询订单记录中的 `licenseDeviceId` 和 `licenseActivatedAt` 字段。
                        *   如果 `licenseDeviceId` 为空 (表示此激活码是首次被尝试激活，且订单已支付):
                            *   将请求中的 `deviceId` 存入订单记录的 `licenseDeviceId`。
                            *   将当前服务器时间存入 `licenseActivatedAt`。
                            *   (可选) 将 `licenseStatus` 字段（如果使用）更新为 "active"。
                            *   返回激活成功，并附带 `alreadyActivated: false` 及其他许可证详情。
                        *   如果 `licenseDeviceId` 已存在:
                            *   若 `licenseDeviceId` 与请求中的 `deviceId` **相同**:
                                *   表示是同一设备在之前已成功激活后再次验证或许可证状态检查。允许操作。
                                *   返回激活成功（或状态检查成功），并附带 `alreadyActivated: true` 及原激活日期和其他许可证详情。
                            *   若 `licenseDeviceId` 与请求中的 `deviceId` **不同**:
                                *   表示激活码已在其他设备激活。激活失败。
                                *   返回错误信息："激活失败：激活码已在其他设备使用。"
                    *   (可选) **激活码是否已过期**: 如果产品非永久授权，需结合订单的 `paidAt` (或 `licenseActivatedAt`) 和产品定义的有效期策略进行判断。
                4.  **返回响应给桌面应用 (JSON) (更新后)**:
                    *   **成功 (首次激活)**: `{ "success": true, "message": "激活成功！", "userEmail": "...", "productId": "...", "activationDate": "YYYY-MM-DD HH:MM:SS", "purchaseDate": "YYYY-MM-DD", "alreadyActivated": false }`
                    *   **成功 (同一设备重复激活/状态检查)**: `{ "success": true, "message": "许可证状态有效。", "userEmail": "...", "productId": "...", "activationDate": "YYYY-MM-DD HH:MM:SS" (原激活日期), "purchaseDate": "YYYY-MM-DD", "alreadyActivated": true }`
                    *   **失败 (示例)**: `{ "success": false, "message": "激活失败：无效的激活码或已在其他设备使用。" }` (后端应根据具体失败原因提供明确的message，例如："激活码不存在", "订单未支付", "激活码已在其他设备使用")
                5.  **日志记录**: 在关键步骤（如数据库连接尝试、查询结果、验证逻辑判断、更新操作、最终返回结果）添加详细日志，方便追踪问题和审计。
        *   桌面应用根据API返回结果更新本地许可证状态并提示用户。客户端的 `license_activation.py` 模块负责处理网络请求、解析响应，并向 `LicenseDialog` 返回结构化的成功或失败信息。`LicenseDialog` 则负责UI更新和用户反馈。

3.  **许可证状态存储 (本地)**:
    *   验证成功后，将许可证信息安全地存储在用户本地。
    *   **存储内容 (更新后)**: 从服务器成功激活响应中获取并存储激活码 (`licenseKey`)、设备ID (`deviceId` - 由客户端生成并发送给服务器进行绑定)、激活状态 (布尔值)、激活日期 (`activationDate`)、购买日期 (`purchaseDate`)、用户邮箱 (`userEmail`)、产品ID (`productId`)。
    *   **存储位置**:
        *   Windows: 注册表 (`HKEY_CURRENT_USER\Software\文智搜`) 或用户 `%APPDATA%\文智搜\` 目录下的加密配置文件。
        *   macOS: `~/Library/Application Support/文智搜/` 下的加密配置文件或 `UserDefaults`。
        *   Linux: `~/.config/文智搜/` 或 `~/.local/share/文智搜/` 下的加密配置文件。
    *   **安全性**: 必须对存储的信息进行加密，防止用户轻易篡改。可以使用平台相关的加密API (如Windows DPAPI, macOS Keychain) 或对称加密算法（密钥需妥善保护，例如基于设备硬件信息但不直接存储设备ID本身作为密钥，或者使用一个固定的密钥但增加混淆）。

4.  **专业功能解锁**:
    *   程序启动时，读取本地存储的许可证状态。
    *   在代码中，通过检查此状态 (例如 `LicenseManager.is_pro()`) 来决定是否启用/禁用专业版功能模块或UI元素。
    *   例如: `if license_manager.is_feature_available("WZS_PRO_PERPETUAL"): # enable pro features`

5.  **停用许可证 (可选未来功能)**:
    *   如果实现设备限制，应提供停用功能，允许用户在更换电脑前解除当前设备的绑定。
    *   需要调用后端API (例如 `api/deactivate-license.js`) 实现。

**难点与注意事项**:
*   **在线验证的安全性**: `api/activate-license.js` 端点需要保护，例如通过速率限制、输入验证，防止滥用。
*   **本地存储的安全性**: 防止用户破解本地许可证文件是持续的挑战。需要较强的加密措施和可能的反调试/反篡改技术。
*   **设备ID生成**: 生成稳定且唯一的`deviceId`需要仔细考虑。
    *   **Windows**: 可以组合CPU ID, 主板序列号, MAC地址等信息，取其哈希值。需要处理权限问题 (例如管理员权限才能获取某些硬件信息)。
    *   **macOS**: 可以使用 `IOPlatformUUID`。
    *   **Linux**: 可以组合 `/sys/class/dmi/id/product_uuid` 或其他硬件信息。
    *   **跨平台方案**: 可以考虑使用如 `py-machineid` 这样的库，但要注意其稳定性和唯一性保证。
    *   **隐私**: 确保用户了解哪些信息被用于生成设备ID。
*   **网络依赖**: 在线验证要求用户在激活时联网。激活成功后，日常使用应依赖本地存储的状态，避免每次启动都联网验证（除非有定期在线检查的需求）。
*   **用户体验**: 激活过程应尽可能简单流畅。错误提示要清晰。

---

## 5. 第三方服务集成

### 5.1 易支付 (Yizhifu)

*   **商户后台配置**:
    *   注册商户号。
    *   配置产品信息（如果平台支持）。
    *   **配置异步通知URL**: 指向 `https://<您的阿里云ECS域名>/api/payment-callback`。
    *   **配置同步跳转URL**: 指向 `${process.env.FRONTEND_SUCCESS_URL}` (或其他成功页面)。
    *   获取PID和KEY。
    *   **配置授权支付域名**: 将 `azariasy.github.io` 添加到授权支付域名列表，并等待审核通过。
*   **API对接**:
    *   仔细阅读易支付的API文档，理解其参数、签名算法、返回格式和通知机制。
    *   测试环境和生产环境的切换。

### 5.2 邮件服务 (SMTP - QQ邮箱)

*   **`nodemailer` 配置 (示例)**:
    ```javascript
    const nodemailer = require('nodemailer');
    let transporter = nodemailer.createTransport({
        host: process.env.SMTP_HOST, // "smtp.qq.com"
        port: parseInt(process.env.SMTP_PORT || "465"), // 465 for SSL, 587 for TLS
        secure: process.env.SMTP_SECURE === 'true', // true for 465, false for other ports (587 uses STARTTLS)
        auth: {
            user: process.env.SMTP_USER, // "your_qq_email@qq.com"
            pass: process.env.SMTP_PASS  // QQ邮箱的授权码
        }
    });
    // ...
    // await transporter.sendMail({ 
    //     from: `"${process.env.EMAIL_FROM_NAME || '文智搜'}" <${process.env.EMAIL_FROM_ADDRESS}>`, // 例如："文智搜" <your_qq_email@qq.com>
    //     to, 
    //     subject, 
    //     html 
    // });
    ```
*   **注意事项**:
    *   **授权码**: QQ邮箱SMTP发信**必须使用授权码**，而不是邮箱的登录密码。需要在QQ邮箱设置中开启SMTP服务并生成授权码。
    *   **发件人信誉**: 新邮箱或不常发送的邮箱容易被标记为垃圾邮件。
    *   **SPF/DKIM/DMARC**: 为发件域名配置这些记录有助于提高邮件送达率 (对于直接使用 `@qq.com` 邮箱，这些由腾讯管理)。
    *   **邮件内容**: 避免使用过多营销词汇和可疑链接，邮件内容应简洁明了。
    *   **退信处理**: 考虑如何处理发送失败或被退回的邮件。QQ邮箱可能会有发送频率和数量的限制。

---

## 6. 整体流程中的关键点与挑战

1.  **安全性**:
    *   **支付安全**: 依赖易支付平台的安全性。回调验证是自身系统能做的最重要一步。
    *   **激活码安全**: 生成、存储、传输、验证的全链路安全。在线验证比离线验证安全得多。
    *   **API安全**: 后端API应有适当的速率限制、输入验证，防止恶意调用。
    *   **敏感信息保护**: API密钥、数据库凭证、邮箱密码等通过环境变量管理，不硬编码。

2.  **数据一致性与事务处理**:
    *   支付成功后，更新数据库、生成激活码、发送邮件这几步最好能保证原子性或最终一致性。
    *   例如：先更新数据库标记支付成功和生成激活码，再尝试发送邮件。若邮件发送失败，订单状态仍为已支付且有激活码，可人工介入或用户联系客服获取。

3.  **错误处理与日志记录**:
    *   **前端**: 清晰的用户错误提示。桌面应用中 `LicenseDialog` 的错误提示和流程控制得到优化，确保在激活失败或发生异常时用户界面保持响应。
    *   **后端 (阿里云 ECS)**: 详尽的日志记录（请求、响应、错误堆栈、关键操作步骤），便于追踪问题。`api/activate-license.js` 模块增加了针对数据库连接、激活验证各步骤的详细日志。使用如 `pm2` 管理 Node.js 应用并配置日志。
    *   定义统一的错误码和错误信息格式，确保前后端对于错误场景的理解一致。

4.  **可测试性**:
    *   **支付模拟**: 如何在没有真实支付的情况下测试支付回调逻辑？（易支付可能提供沙箱环境，或自行模拟HTTP请求）。
    *   **邮件测试**: 使用测试邮箱，检查邮件内容和送达情况。
    *   单元测试和集成测试。

5.  **用户体验 (UX)**:
    *   整个流程应尽可能顺畅，减少用户操作步骤。
    *   明确的指引和反馈。
    *   激活失败时提供有用的帮助信息。

6.  **维护与迭代**:
    *   易支付API可能会变更。
    *   邮件服务商政策可能调整。
    *   持续监控系统运行状态。

---

本文档为v1.1版本 (基于阿里云ECS和在线激活更新)，后续将根据实际开发进展和遇到的问题进行更新。 